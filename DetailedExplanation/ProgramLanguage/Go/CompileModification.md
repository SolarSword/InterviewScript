# go escape analysis （Golang逃逸分析）
编译器决定内存分配位置的方式，就称之为逃逸分析。逃逸分析由编译器完成，作用于编译阶段。

（为什么？）Go程序会在两个地方为变量分配内存，一个是全局的堆（heap），用来动态分配内存；另一个是每个goroutine的栈（stack）空间。由于Go语言实现了垃圾回收（Garbage Collector,GC）机制，Go语言的内存管理是自动的，通常开发者不需要关心内存分配在栈还是堆上。

如果内存分配在栈上，函数在执行结束后就会自动回收内存；如果分配在堆上，那部分内存是在函数结束后某个时间点被GC回收。而且在栈上分配和回收内存的开销很低。只需要两个CPU指令：`PUSH`和`POP`；那么在栈上分配内存的话，消耗的只是数据拷贝到内存的时间，考虑到较高的内存IO，这个效率是很高的。

但是如果分配在堆上，GC（这里指Garbage Collection）就是一个很大的额外开销。

所以因为某些原因，部分局部变量可能不会被分配到栈上随着函数执行结束被回收，而“逃逸”到了堆上去，对于这种情况的分析就是逃逸分析，也是为什么叫逃逸。这种“逃逸”不能说是局部变量“逃逸”了，而是编译器通过分析，得出某个变量不能分配在栈上而是得分配到堆上，因而“让”它去逃逸。
- **指针逃逸**
  - 如果某个函数创建并返回了一个指针，显然这个指针的空间并不会随着这个函数的执行结束而回被回收，因此它只能被分配在堆上，这就是某个局部变量逃逸到堆。
  >编译时，在命令`go build`后加上`-gcflags=-m`就可查看变量逃逸状况。如`go build -gcflags=-m main.go`。出现`escape to heap`就表示某个局部变量逃逸到了堆。
  - 数组传参也会。`func([]string)`: 函数类型，进行`[]string{"value"}`赋值，会使传递的参数出现逃逸现象。
- **interface{}动态类型逃逸**
  - 空接口`interface{}`可以表示任意类型。如果函数的参数由interface{}类型，在编译时很难确定其参数的具体类型，那么也会发生逃逸。
  - `[]interface{}`数据类型，通过`[]`赋值必定会出现逃逸。
  - `map[string]interface{}`类型尝试通过赋值，必定会出现逃逸。
  - `map[interface{}]interface{}`类型尝试通过赋值，会导致key和value的赋值，出现逃逸。
  - `map[string][]string`数据类型，赋值会发生[]string发生逃逸。
  - `[]*int`数据类型，赋值的右值会发生逃逸现象。
- **channel中的逃逸**
  - `chan []string`数据类型，向当前channel中传输`[]string{"value"}`会发生逃逸现象。
- **栈空间不足导致的逃逸**
  - OS对于内核线程使用的栈空间大小是有限制的。
    >64位机通常是8MB，可以用`ulimit -a`命令查看。
    
    那么如果递归函数实现不当，栈溢出时，就会逃逸。

    当局部变量过大时，也会逃逸。（不同Go版本可能对于大小的限制不一样。）
- **闭包**
  - 例如这样的代码段
    ```Golang
    func Increase() func() int {
	    n := 0
	    return func() int {
		    n++
		    return n
	    }
    }

    func main() {
	    in := Increase()
	    fmt.Println(in()) // 1
	    fmt.Println(in()) // 2
    }
    ```
    >一个函数和对其周围环境（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域。
    因为`Increase()`的返回值是个闭包函数，它访问了外部变量n，那n就会一直存在直到`in`被销毁，因而要逃逸到堆上。

那么逃逸分析对于开发者有什么用呢？
- 首先编译器帮开发者做了这件事情后，开发者就可以从内存管理中被解放出来，从而更专注于代码逻辑。
- 逃逸分析的结果可以为开发者优化代码性能做参考。比如，虽然函数的指针传递不会像值传递那样拷贝整个对象而只是拷贝指针地址，但是由于指针传递会导致内存分配的逃逸、增加GC的负担，因此在对象频繁创建和删除的场景中，指针传递导致的GC开销对于性能的影响就不可忽视。

    一般是对于要修改原对象值、或者占用内存较大的结构体对象，传指针；对于只读的、内存占用较小的结构体对象，传值带来的性能可能更好。