# 唯一索引（Unique Index）和非唯一索引（Non-unique Index）
*唯一索引*是一种通过确保表中没有两个数据行具有完全相同的键值来帮助维护数据完整性的索引。

在创建唯一索引时，会检查组成索引键的列或表达式中的值是否唯一。如果该表包含具有重复键值的行，那么索引创建过程会失败。为表定义了唯一索引之后，每当在该索引内添加或更改键时就会强制执行唯一性。除了强制数据值的唯一性以外，唯一索引还可以用来提高数据查询速度。

*非唯一索引*不用于对表的强制约束，而是通过维护频繁使用的数据值的排序顺序来提高查询性能。

[参考链接](https://www.ibm.com/docs/zh/db2/10.5?topic=indexes-unique-non-unique)

# 唯一性约束和主键约束
唯一性约束允许该列存在NULL值，只要不重复即可更新；主键约束不允许有重复，也不允许有NULL值。

在创建唯一性约束和主键约束时可以创建聚簇索引和非聚簇索引，但是默认情况下主键约束产生聚簇索引，唯一性约束产生非聚簇索引。

要注意唯一性约束和唯一索引的一些区别：

约束时用来检查数据的正确性的，而索引是用来实现数据查询优化的，目的是不同的。

唯一约束时通过唯一索引来实现的：
*创建唯一约束会在Oracle中创建一个Constraint，同时也会创建一个该约束对应的唯一索引；但是创建唯一索引只会创建一个唯一索引。*

# 索引下推（Index Condition Pushdown）
不使用索引下推时，存储引擎层就是只通过索引检索到数据，然后返回给server层，server层自己判断是否符合条件。（顺带提一句，MySQL中，索引是在存储引擎层中实现的。）

使用了以后可以减少数据查询回表次数以提升性能。

举个例子来说，比方说有这么一张item_info表：
|ID|Name|Type|
|----|----|----|
|1|pen|1|
|2|pencil|1|
|3|doll|2|
|4|bowl|3|
|5|plate|3|

如果这张表里以`(Name,Type)`建立联合索引，然后作如下的查询：

`SELECT * FROM item_info WHERE Name LIKE "p%" AND Type = 3;`

首先，`Name LIKE "p%"`不是等值匹配，那么根据`最左前缀匹配原则`，联合索引`(Name,Type)`中只有`Name`会被存储引擎层给用到。这样的话`ID=1`，`ID=2`和`ID=5`都会被查找到，然后通过回表查询，再将结果返回给server层，一共有3条记录，那么就要回表3次。最后，server层再用`Type=3`将不符合的记录过滤掉。

如果使用了索引条件下推呢？此时`Type=3`这个索引条件会被“下推”到存储引擎层，此时只会有`ID=5`一条被找到，再通过回表查询，此时只用回表1次。